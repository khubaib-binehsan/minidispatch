from __future__ import annotations

import os
import shlex
from pathlib import Path


_ENV_KEYS = (
    "MINI_DISPATCH_HOME",
    "MINI_DISPATCH_DB",
    "MINI_DISPATCH_LOGS",
    "MINI_DISPATCH_DAEMON_LOG",
    "MINI_DISPATCH_DAEMON_PID",
    "MINI_DISPATCH_JOBS_LOGS",
    "MINI_DISPATCH_ENVS",
)


def _write_env_sh(test_home: Path) -> None:
    lines: list[str] = [
        "# Generated by minidispatch tests\n",
        "# Usage: source .minidispatch_test_env/test_env.sh\n",
    ]

    for key in _ENV_KEYS:
        value = os.environ.get(key)
        if value is None:
            continue

        lines.append(f"export {key}={shlex.quote(value)}\n")

    path = test_home / "test_env.sh"
    path.write_text("".join(lines))


def activate_test_env(project_root: Path) -> Path:
    """Activate an isolated test env for the current pytest process.

    This only affects the current Python process (pytest). It does not modify
    your shell or any environment outside the test run.

    Creates/uses a real directory under the repo so you can inspect artifacts.
    """

    test_home = project_root / ".minidispatch_test_env"

    test_home.mkdir(parents=True, exist_ok=True)

    os.environ["MINI_DISPATCH_HOME"] = str(test_home)
    os.environ["MINI_DISPATCH_DB"] = str(test_home / "database.sqlite")
    os.environ["MINI_DISPATCH_LOGS"] = str(test_home / "logs")
    os.environ["MINI_DISPATCH_DAEMON_LOG"] = str(test_home / "logs" / "daemon.log")
    os.environ["MINI_DISPATCH_DAEMON_PID"] = str(test_home / "daemon.pid")
    os.environ["MINI_DISPATCH_JOBS_LOGS"] = str(test_home / "jobs_logs")
    os.environ["MINI_DISPATCH_ENVS"] = str(test_home / "envs")

    _write_env_sh(test_home)

    return test_home
